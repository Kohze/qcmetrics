%\VignetteEngine{knitr}
%\VignetteIndexEntry{The 'qcmetrics' infrastructure for quality control and reporting}
%\VignetteKeywords{Bioinformatics, Quality control, reporting}
%\VignettePackage{qcmetrics}

\documentclass[12pt,a4paper,english]{scrartcl}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage[authoryear,round]{natbib}
\usepackage[auth-sc]{authblk}
\usepackage{setspace}
\onehalfspacing

\usepackage[final]{pdfpages}

% caption formatting
\setcapindent{0em}
\setkomafont{captionlabel}{\sffamily\bfseries}
\setkomafont{caption}{\sffamily}

\renewcommand\Authands{ and }

\newcommand{\R}{\texttt{R} }
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\mbox{\normalfont\textsf{#1}}}}
\newcommand{\email}[1]{\href{mailto:#1}{\normalfont\texttt{#1}}}
%% colors
\definecolor{Red}{rgb}{0.7,0,0}
\definecolor{Blue}{rgb}{0,0,0.8}

\usepackage{geometry}
\geometry{verbose,
  tmargin = 2.5cm,
  bmargin = 2.5cm,
  lmargin = 3.0cm,
  rmargin = 3.0cm}

\usepackage{hyperref}
\usepackage{breakurl}
\hypersetup{%
  pdfusetitle,
  bookmarks = {true},
  bookmarksnumbered = {true},
  bookmarksopen = {true},
  bookmarksopenlevel = 2,
  unicode = {true},
  breaklinks = {false},
  hyperindex = {true},
  colorlinks = {true},
  linktocpage = {true},
  plainpages = {false},
  linkcolor = {Blue},
  citecolor = {Blue},
  urlcolor = {Red},
  pdfstartview = {Fit},
  pdfpagemode = {UseOutlines},
  pdfview = {XYZ null null null}
}


\author{
  Laurent Gatto\thanks{\email{lg390@cam.ac.uk}}
}


\affil{
  Computational Proteomics Unit\\
  Cambridge Center for Proteomics\\
  University of Cambridge
}

\begin{document}

\title{The \Rpackage{qcmetrics} infrastructure for quality control and automatic reporting}

\maketitle

%% Abstract and keywords %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vskip 0.3in minus 0.1in
\hrule
\begin{abstract}
  The \Rpackage{qcmetrics} package is a framework that provides simple data containers for quality metrics and support for automatic report generation. This document briefly illustrates the core data structures and then demonstrates the generation and automation of quality control reports for microarray and proteomics data.  
\end{abstract}
\textit{Keywords}: Bioinformatics, Quality control, reporting, visualisation 
\vskip 0.1in minus 0.05in
\hrule
\vskip 0.2in minus 0.1in
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\tableofcontents

<<env, include=FALSE, echo=FALSE, cache=FALSE>>=
library("knitr")
opts_chunk$set(fig.align = 'center', 
               fig.show = 'hold', 
               par = TRUE,
               prompt = TRUE,
               eval = TRUE,
               stop_on_error = 1L,
               comment = NA)
options(replace.assign = TRUE, 
        width = 55)

suppressPackageStartupMessages(library("qcmetrics"))
suppressPackageStartupMessages(library("MAQCsubsetAFX"))
suppressPackageStartupMessages(library("yaqcaffy"))
suppressPackageStartupMessages(library("affy"))
suppressPackageStartupMessages(library("AnnotationDbi"))
suppressPackageStartupMessages(library("RforProteomics"))
suppressPackageStartupMessages(library("mzR"))
suppressPackageStartupMessages(library("MSnbase"))
set.seed(1)
@ 
%%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introduction}\label{sec:intro} 

Why QC is important. Need for standardisation and automation. Package is general framework. Below we demonstrate how to create QC objects, how to bundle them to create sets of QC metrics and how to generate reports in multiple formats. The goal is to provide means to develope QC pipeline and automate the generation of reports through wrapper QC functions \ref{sec:wrapper}. It is however hoped that the community will go a step further by developing and distributing fully fledged QC packages for dedicated applications \ref{sec:qcpkg}. Need for repository for QC packages.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The QC classes}\label{sec:qcclasses}

The package provides are two types of QC containers. The \Robject{QcMetric} class stores data and visualisation functions for single metrics. Several such metrics can be bundles into a \Robject{QcMetrics} instances, that can be used as templates for automaated report generation. Below, we will provide a quick overview of how to create respective \Robject{QcMetric} and \Robject{QcMetrics} instances. More details are available in the respective documentations. 

\subsection{The \Robject{QcMetric} class}

A QC metric is composed of a description ( \Robject{name} in the code chunk below), some QC data (the \Robject{qcdata}) and a \Robject{status} that defines of the metric is deemed of good quality (coded as \Robject{TRUE}), bad quality (coded as \Robject{FALSE}) or not yet evaluated (coded as \Robject{NA}). Individual metrics can be displayed as a short textual summary or plotted. To do the former, one can use the default \Rfunction{show} method.

<<qcmetric>>=
library("qcmetrics")
qc <- QcMetric(name = "A test metric")
qcdata(qc, "x") <- rnorm(100)
qcdata(qc) ## all available qcdata
summary(qcdata(qc, "x")) ## get x
show(qc) ## or just qc
status(qc) <- TRUE
qc
@

Plotting \Robject{QcMetric} instances requires to implement a plotting method that is adequate to the data at hand. We can use a \Rfunction{plot} replacement method to define our custom code.

<<qcmetricplot, dev='pdf', fig.width = 4, fig.height = 4>>=
plot(qc)
plot(qc) <-
    function(object, ... ) boxplot(qcdata(object, "x"), ...)
plot(qc)
@

\subsection{The \Robject{QcMetrics} class}

A \Robject{QcMetrics} object is essentially just a list of individual \Robject{QcMetric} instances. It is also possible to set a list of metadata to describe the source of the QC metrics.

<<qcmetrics>>=
qcm <- QcMetrics(qcdata = list(qc))
qcm
metadata(qcm) <- list(metadata1 = 123,
                      metadata2 = "abc")
@

The \Robject{QcMetrics} can then be passed to the \Rfunction{qcReport} method to generate reports, as described in more details below. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Creating QC pipelines}\label{sec:pipeline}


\subsection{Microarray degradation}

We will use the \Robject{refA} Affymetrix arrays from the \Rpackage{MAQCsubsetAFX} package as an example data and investigate the RNA degradation using the \Rfunction{AffyRNAdeg} from \Rpackage{affy} \cite{Gautier:2004} and the actin and GAPDH $\frac{3'}{5'}$ ratios, as calculated in the \Rpackage{yaqcaffy} package \cite{yaqcaffy}. The first code chunk retrieves the data and computes the QC data.

<<maqcdata, cache = TRUE>>=
library("MAQCsubsetAFX")
data(refA)
library("affy")
deg <- AffyRNAdeg(refA)
library("yaqcaffy")
yqc <- yaqc(refA)
@

We then create two \Robject{QcMetric} instances, one for each of our quality metrics. 

<<maqc1>>=
qc1 <- QcMetric(name = "Affy RNA degradation slopes")
qcdata(qc1, "deg") <- deg
plot(qc1) <- function(object, ...) {
    x <- qcdata(object, "deg")
    nms <- x$sample.names
    plotAffyRNAdeg(x, col = 1:length(nms), ...)
    legend("topleft", nms, lty = 1, cex = 0.8, 
           col = 1:length(nms), bty = "n")
}
status(qc1) <- TRUE
qc1
@


<<maqc2>>=
qc2 <- QcMetric(name = "Affy RNA degradation ratios")
qcdata(qc2, "yqc") <- yqc
plot(qc2) <- function(object, ...) {
    par(mfrow = c(1, 2))
    yaqcaffy:::.plotQCRatios(qcdata(object, "yqc"), "all", ...)
}
status(qc2) <- FALSE
qc2
@

Then, we combine the individual QC items into a \Robject{QcMetrics} instance. 

<<maqcm>>=
maqcm <- QcMetrics(qcdata = list(qc1, qc2))
maqcm
@

%% Running this one with echoing so that the auxiliary files, 
%% in particular the figure directory does not get deleted, as 
%% it is also created and needed by the vignette itself.
<<maqcreport0, echo = FALSE, message = FALSE>>=
qcReport(maqcm, reportname = "rnadeg", clean = FALSE)
@

With our \Robject{QcMetrics} data, we can easily generate quality reports in several different formats. Below, we create a \texttt{pdf} report, which is the default type. Using \texttt{tpye = "html"} would generate the equivalent report in \texttt{html} format. See \Rfunction{?qcReport} for more details.

<<maqcreport, eval = FALSE>>=
qcReport(maqcm, reportname = "rnadeg", type = "pdf")
@

The resulting report is shown below. Each \Robject{QcMetric} item generates a section named according to the object's name. A final summary section shows a table with all the QC items and their status. The report concludes with a detailed session information section.

\includepdf[pages=-,nup=2x2, frame=TRUE]{rnadeg.pdf}

\clearpage

\subsection{A wrapper function}\label{sec:wrapper}

Once an appropriate set of quality metrics have been identified, the generation of the \Robject{QcMetrics} instances can be wrapped up for automation. 

<<maqcwrap, tidy=FALSE>>=
rnaqc <- function(input, status,
                  type, reportname = "rnadegradation") {
    if (is.character(input))
        input <- ReadAffy(input)
    ## first QC item
    qc1 <- QcMetric(name = "Affy RNA degradation slopes")
    qcdata(qc1, "deg") <- AffyRNAdeg(refA)
    plot(qc1) <- function(object) {
        x <- qcdata(object, "deg")
        nms <- x$sample.names
        plotAffyRNAdeg(x, col = 1:length(nms))
        legend("topleft", nms, lty = 1, cex = 0.8, 
               col = 1:length(nms), bty = "n")
    }
    if (!missing(status))
        status(qc1) <- status[1]
    ## second QC item
    qc2 <- QcMetric(name = "Affy RNA degradation ratios")
    qcdata(qc2, "yqc") <- yaqc(refA)
    plot(qc2) <- function(object) {
        par(mfrow = c(1, 2))
        yaqcaffy:::.plotQCRatios(qcdata(object, "yqc"), "all")
    }
    if (!missing(status))
        status(qc2) <- status[2]
    qcm <- QcMetrics(qcdata = list(qc1, qc2))
    if (!missing(type))         
        qcreport(qcm, reportname, type = type,
                 title = "Affymetrix RNA degradation report")
    invisible(qcm)
}
@


If is now possible to generate a report from a set of CEL files or directly from an \Robject{affybatch} object. The \code{status} argument allows to directly set the statuses of the individual QC items. These can also be set later, as illustrated below. 

<<qcwrap2, cache = TRUE>>=
myqc <- rnaqc(refA)
status(myqc)
## check the QC data 
status(myqc) <- c(TRUE, FALSE)
@

<<test, echo = FALSE>>=
## stopifnot(all.equal(myqc, maqcm))
@

The report can be generated manually with \code{qcReport(myqc)} or directly with the wrapper function as follows:

<<qcwrap3, eval = FALSE>>=
myqc <- rnaqc(refA, type = "pdf")
@

\subsection{Proteomics}

To illustrate a simple QC analysis for proteomics data, we will download dataset \texttt{PXD00001} from the ProteomeXchange repository in the \texttt{mzXML} format \citep{Pedrioli:2004}. The MS$^2$ spectra from that mass-spectrometry run are then read into \R and stored as an \Robject{MSnExp} experiment using the \Rfunction{readMSData} function from the \Rpackage{MSnbase} package \cite{Gatto:2012}. 

<<protdata, eval=TRUE, cache=TRUE>>=
library("RforProteomics")
msfile <- getPXD000001mzXML()
library("MSnbase")
exp <- readMSData(msfile, verbose = FALSE)
@

The \Robject{QcMetrics} will consist of 3 items, namely a chromatogram constructed with the MS$^2$ spectra precursor's intensities, two figures illustrating the total ion count and precursor charges in the MS space and an $\frac{m}{z}$ delta plot illustrates the suitability of MS2 spectra for identification (see \Rfunction{?plotMzDelta} or \cite{Foster:2011}). 


<<protqc1, cache=TRUE, tidy=FALSE>>=
qc1 <- QcMetric(name = "Chromatogram")
x <- rtime(exp)
y <- precursorIntensity(exp)
o <- order(x)
qcdata(qc1, "x") <- x[o]
qcdata(qc1, "y") <- y[o]
plot(qc1) <- function(object, ...)
    plot(qcdata(object, "x"),
         qcdata(object, "y"),
         col = "darkgrey", type ="l",
         xlab = "retention time",
         ylab = "precursor intensity")
@

<<protqc2, cache=TRUE>>=
qc2 <- QcMetric(name = "MS space")
qcdata(qc2, "p2d") <- plot2d(exp, z = "charge", plot = FALSE)
plot(qc2) <- function(object) { 
    require("ggplot2")
    print(qcdata(object, "p2d"))
}
@

<<protqc3, cache=TRUE, messages=FALSE, tidy=FALSE, warnings=FALSE>>=
qc3 <- QcMetric(name = "M/Z delta plot")
qcdata(qc3, "pmz") <- plotMzDelta(exp, plot = FALSE,
                                  verbose = FALSE)
plot(qc3) <- function(object) 
    suppressWarnings(print(qcdata(object, "pmz")))
@ 

Note that we do not store the raw data in any of the above instances, but always pre-compute the necessary data that or plots that are then stored as \Robject{qcdata}. Let's now combine the three items into a \Robject{QcMetrics} object, decorate it with custom meta-data using the MIAPE information from the \Robject{MSnExp} object and generate a report.

<<protqcm, tidy=FALSE>>=
protqcm <- QcMetrics(qcdata = list(qc1, qc2, qc3))
metadata(protqcm) <- list(
    data = "PXD000001",
    instrument = experimentData(exp)@instrumentModel,
    source = experimentData(exp)@ionSource,
    analyser = experimentData(exp)@analyser,
    detector = experimentData(exp)@detectorType,
    manufacurer = experimentData(exp)@instrumentManufacturer)
@

%% Running this one with echoing so that the auxiliary files, 
%% in particular the figure directory does not get deleted, as 
%% it is also created and needed by the vignette itself.
<<protreport0, echo = FALSE, message = FALSE>>=
qcReport(protqcm, reportname = "protqc", clean=FALSE, quiet=TRUE)
@

The status column of the summary table is empty as we have not set the QC items statuses yet. 

<<protreport, eval=FALSE>>=
qcReport(protqcm, reportname = "protqc", clean=FALSE, quiet=TRUE)
@

\includepdf[pages=-,nup=2x2, frame=TRUE]{protqc.pdf}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Report generation}\label{sec:report}

The report generation is handled by dedicated packages, in particular \Rpackage{knitr} \cite{Xie:2013} for the \texttt{pdf} and \texttt{html} formats.

\subsection{Custom reports}

It is possible to customise reports for any of the existing types. The generation of the \texttt{pdf} report is based on a \texttt{tex} template \texttt{knitr-template.tex} that is available with the package\footnote{You can find its location with \Rfunction{system.file("templates", package = "qcmetrics")}.}. The \Rfunction{qcReport} method accepts the path to a custom \Robject{template} as argument. 

\paragraph{TODO} Similarly, \texttt{html} reports can be customised by providing a \texttt{css} definition as \Robject{template} argument when calling \Rfunction{qcReport}. 

It is also possible to generate the \texttt{tex} and \texttt{Rmd} (\R markdown) intermediates to the \texttt{pdf} and \texttt{html} outputs.

\subsection{New report types}

The existing report types are documented in the \Rfunction{qcReport} manual. Below, we will describe how to create new types, using as an example a simple plain text report. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{QC packages}\label{sec:qcpkg}


\clearpage

\singlespacing

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Session information}\label{sec:sessionInfo} 

All software and respective versions used to produce this document are listed below.

<<sessioninfo, results='asis', echo=FALSE>>=
toLatex(sessionInfo())
@

\bibliographystyle{plainnat}
\bibliography{qcmetrics}

\end{document}

